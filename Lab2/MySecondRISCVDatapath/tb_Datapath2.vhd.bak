library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity tb_Datapath2 is
  generic(gCLK_HPER   : time := 10 ns;
          DATA_WIDTH  : integer := 32);  
end tb_Datapath2;

architecture mixed of tb_Datapath2 is

    -- Component Under Test (C.U.T)
    component Datapath2 is
        port(
            clock   : in std_logic;
            reset   : in std_logic;

            ALUSrc  : in std_logic;
            IM_Sw   : in std_logic;
            Imm     : in std_logic_vector(15 downto 0);
            AddSub  : in std_logic;
            ovflw   : out std_logic;

            Reg_Wr  : in std_logic;
            Rd      : in std_logic_vector(4 downto 0);
            RS1     : in std_logic_vector(4 downto 0);
            RS2     : in std_logic_vector(4 downto 0);

            Mem_Wr  : in std_logic;
            mem_Sel : in std_logic_vector(9 downto 0)
        );
    end component;

    -- Signals to connect to Datapath2
    signal CLK   : std_logic := '0';
    signal reset   : std_logic := '1';

    signal ALUSrc  : std_logic := '0';
    signal IM_Sw   : std_logic := '0';
    signal Imm     : std_logic_vector(15 downto 0) := (others => '0');
    signal AddSub  : std_logic := '0';
    signal ovflw   : std_logic;

    signal Reg_Wr  : std_logic := '0';
    signal Rd      : std_logic_vector(4 downto 0) := (others => '0');
    signal RS1     : std_logic_vector(4 downto 0) := (others => '0');
    signal RS2     : std_logic_vector(4 downto 0) := (others => '0');

    signal Mem_Wr  : std_logic := '0';
    signal mem_Sel : std_logic_vector(9 downto 0) := (others => '0');

    constant CLK_PERIOD : time := 10 ns;

begin

    -- Instantiate the Datapath2
    uut: Datapath2
        port map(
            clock   => CLK,
            reset   => reset,

            ALUSrc  => ALUSrc,
            IM_Sw   => IM_Sw,
            Imm     => Imm,
            AddSub  => AddSub,
            ovflw   => ovflw,

            Reg_Wr  => Reg_Wr,
            Rd      => Rd,
            RS1     => RS1,
            RS2     => RS2,

            Mem_Wr  => Mem_Wr,
            mem_Sel => mem_Sel
        );

    -- Clock generation
P_CLK: process
  begin
    CLK <= '1';         -- clock starts at 1
    wait for gCLK_HPER; -- after half a cycle
    CLK <= '0';         -- clock becomes a 0 (negative edge)
    wait for gCLK_HPER; -- after half a cycle, process begins evaluation again
  end process;

-- This process resets the sequential components of the design.
  -- It is held to be 1 across both the negative and positive edges of the clock
  -- so it works regardless of whether the design uses synchronous (pos or neg edge)
  -- or asynchronous resets.
  P_RST: process
  begin
  	reset <= '0';   
    wait for gCLK_HPER/2;
	reset <= '1';
    wait for gCLK_HPER*2;
	reset <= '0';
	wait;
  end process;

P_TEST_CASES: process
begin
	wait for gCLK_HPER*3; --Wait for reset to finish
	wait for gCLK_HPER/2; --Change inputs on clk midpoints



wait;
end process;
end mixed;